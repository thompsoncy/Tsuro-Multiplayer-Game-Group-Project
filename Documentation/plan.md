Part 1.

Our team has analyzed the Tsuroâ€™ project specifications provided to us and have summarized our thoughts below in two parts an automated Tsuro player and a Tsuro game software. The reason for this division is that we have concluded that this project would best be split into two applications a player software that handles player interaction and a server software that handles managing and updating the actual gamestate. Communication between the two in some form would be required for the game to run.

For an automated Tsuro player there are a few basic pieces. First there must be a piece that is able to take in and understand the gamestate which is composed of 3 things, the current state of the tile board, the current state of the player pieces in terms of location in the aforementioned tile board and the tile choices the player has on any given turn. With this information there should be a planning piece. The automated player will have to understand which tile placement is best while considering the two tile choices, the placement locations, and rotations and the current gamestate. There should be an interaction piece, the automated player must communicate to the game its tile choice, where that tile should be placed, and how much it should be rotated before placing. Finally there will have to be some sort of networking piece that is able to connect to the game software, retrieve the gamestate and send its interactions.


For Tsuro game software there are a few basic pieces as well. First there must be a piece to hold the gamestate which includes a 10 by 10 board of tiles each containing 8 ports and a current rotation and the gamestate must hold a list of player info, such as their location and color as well as whose turn it is and the two randomly generated tiles. The game software must have a piece which is able to move from one game state to the next, which includes moving between startup, shutdown and moving between individual turns. There will have to be a server piece that is able to handle and keep track of the multiple connected players and send out and receive the appropriate information from the players.  


Part 2.

We plan to proceed with implementing these pieces in the same fashion, two different applications which are again a Tsuro player software and a Tsuro game software. Before any implementation plans are decided we are committed to creating and rerunning tests at every stage of implementation of this project. As a natural addition to this plan for modular tests we plan to have a demo be created at every stage of implementation as both an additional test case and to show the functionality that has been implemented. The first thing that will be implemented is the data representation of the game on the game software side which we will call the gamestate. The number one reason for this is that both applications rely on this gamestate for all of their actual functionality and thus knowing the gamestate is required for the design of everything else. Yet while implementing the gamestate we will have to keep in mind the fact that the whole thing will have to be communicated to and or synchronized with every player software connected to the game software. Secondly we would wish to implement the actual functionality connected to this gamestate such as the following of paths created on the tile board, the placing and generation of tiles and the rules there in. At the third step of implementation we would wish to start designing the interactions and connections between the player software and the game software, there are a few open questions here such as how much of the gamestate will the player software hold and how much will be sent by the game software. At this point the software will require full body testing along with the tests created at every stage of implementation and thus an automated player will be implemented for robust testing and as an additional feature. 
